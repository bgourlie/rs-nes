<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PPU Cycle Legend</title>
</head>
<body>

<canvas id="screen" width="1023" height="786">
</canvas>

<div id="operation_buttons"></div>

<script>
    const SCANLINES = 262;
    const CYCLES_PER_SCANLINE = 341;
    const PIXELS_PER_CYCLE = 3;
    const MARGIN_WIDTH = 0;
    const PIXEL_STRIDE = PIXELS_PER_CYCLE + MARGIN_WIDTH;
    const SCREEN_HEIGHT = SCANLINES * PIXEL_STRIDE;
    const SCREEN_WIDTH = CYCLES_PER_SCANLINE * PIXEL_STRIDE;
    const canvas = document.getElementById("screen");
    const operationButtons = document.getElementById("operation_buttons");
    const ctx = canvas.getContext("2d");

    const operations = {{operations | safe | json_encode()}}
    const pixelMap = {{ cycle_code_map | safe | json_encode() }};
    const scanlines = {{ scanlines | safe | json_encode() }};

    function updateScreen(operation) {
        window.requestAnimationFrame(() => {
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

            for(let y = 0; y < scanlines.length; y += 1) {
                for(let x = 0; x < scanlines[y].length; x += 1) {
                    if (scanlines[y][x].includes(operation)) {
                        ctx.fillStyle = "red";
                    } else {
                        ctx.fillStyle = "gray";
                    }
                    ctx.fillRect(x * PIXEL_STRIDE, y * PIXEL_STRIDE, PIXELS_PER_CYCLE, PIXELS_PER_CYCLE);
                }
            }
        });
    }

    for (let operation of operations) {
        const button = document.createElement("button");
        button.appendChild(document.createTextNode(operation));
        button.addEventListener("click", () => updateScreen(operation));
        operationButtons.appendChild(button);
    }

    updateScreen("");
</script>
</body>
</html>